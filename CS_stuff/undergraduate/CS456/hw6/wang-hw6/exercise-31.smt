(use exercise-4.smt)

(class  Natural Magnitude
        (degree digits b)
        (method base () b)
        (method decimal () (locals temp)
                (set temp (new List))
                (do: digits (block (x) (addFirst: temp x)))
                temp)
        (method digits: (aSequence)
                (set b 10)
                (set degree (+ 1 (size aSequence)))
                (set digits (from: Array aSequence))
                self)
        (method digit: (anIndex)
                (at:ifAbsent: digits anIndex [0]))
        (method digit:put: (anIndex aDigit)
                (at:put: digits anIndex aDigit ))
        (method doDigits: (aBlock)
                (locals index)
                (set index (firstKey digits))
                (timesRepeat: (size digits)
                              [(value aBlock (at: digits index))
                               (set index (+ index 1))]))
        (method trim () (set degree (size digits)))
        (method degree () degree)
        (method makeEmpty: (aDegree)
                (set degree aDegree))
        (method + (aNatural) (locals index carry result curr a1 a2 i mult res)
                (set result (new List))
                (set index 1)
                (set mult 1)
                (set carry 0)
                (set curr 0)
                (set a1 (size (decimal aNatural))) (set a2 (size digits)) (if (< a1 a2) [(set a1 a2)] [a1])
                (while [(< index (+ 1 a1))]
                  [(set curr (+ carry (+ (digit: aNatural index) (digit: self index))))
                   (if (>= curr b)
                     [(begin (set carry 1)
                             (add: result (mod: curr 10)))]
                     [(set carry 0) (add: result curr)])
                   (set index (+ 1 index))])

                (if (= 1 carry) [(add: result 1)] [0])
                (set res 0)
                (set index 1)
                (do: result (block (x)
                                   (set res (+ res (* mult x)))
                                   (set mult (* 10 mult))
                                   (set index (+ 1 index))))
                res)
        (method subtract:withDifference:ifNegative: (aNatural diffBlock negativeBlock)
                (locals index carry result curr a1 a2 mult res)
                (set curr 0)
                (set carry 0)
                (set index 1)
                (set mult 1)
                (set result (new List)) (set a1 (size (decimal aNatural))) (set a2 (size digits))
                (if (< a1 a2) [(set a1 a2)] [a1])
                (while [(< index (+ 1 a1))]
                  [(set curr (- (- (digit: self index) (digit: aNatural index) )  carry))
                   (set index (+ 1 index))
                   (if (< curr 0)
                     [(begin (set carry 1)
                             (add: result (+ 10 curr)))]
                     [(set carry 0) (add: result curr)])])
                (set index 1)
                (set res 0)
                (do: result (block (x)
                                   (set res (+ res (* mult x)))
                                   (set mult (* 10 mult))
                                   (set index (+ 1 index))))
                (if (> 1 carry) [(value diffBlock res)] [(value negativeBlock)]))

        (method - (aNatural) (subtract:withDifference:ifNegative: self aNatural (block (x) x) [(error: self #negative)]))
        (class-method new: (anInteger) (locals temp)
                      (set temp (new List))
                      (while [(> anInteger 0)]
                        [(add: temp (mod: anInteger 10))
                         (set anInteger (div: anInteger 10))])
                      (digits: (new self) temp)))
