<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Lab 1</title>
</head>

<body>
<h1><center>CS252 Lab 1: C/C++ Programming and GDB</h1></center>

<H1><A href="LAB01Fall2012.pdf">Lab Slides</a></H1>

<h2>Goal</h2>

<p>
  The goal of this lab is to help you better understand both the
  tools that are available to you as a programmer, and the UNIX
  environment.  A
  substantial part of being a good programmer is understanding the 
  tools available to you and using them correctly.  
  The lab also serves as a review for C/C++.
</p>

<h2>Advice</h2>

<h3>The Editor</h3>

<p>
  Picking an editor that can work for you is critical to efficient
  programming.  This does not include such simple text editors as pico
  or the CDE text editor.  There are plenty of programmers' editors
  out there, and several are available on the sslab machines 
  (sslab01.cs.purdue.edu to sslab20.cs.purdue.edu).  If
  you are iin a different machine you may ssh to any of these machines.
  We recommend using either XEmacs or vim.  If you are not already familiar with vim,
  XEmacs will probably present you with the simplest learning curve.
</p>

<h4>XEmacs</h4>

<p>
  XEmacs is a fork of the GNU emacs text editor with a comprehensive
  graphic interface.  Virtually all of the operations you would want
  to do are available from drop-down menus and toolbars, letting you
  learn the keybindings and complex commands at your own pace.  <b>You
  do not need to learn complex commands in order to get started using
  XEmacs.</b>  
</p>
<p>
  To start XEmacs, type:
</p>
<blockquote>
  <p>
    <i>csh&gt;</i> <tt>xemacs &amp;</tt>
  </p>
</blockquote>
<p>
  Once you have started XEmacs, you can open files, copy, paste, save,
  and perform other standard operations using the pull-down menus and
  toolbars.  You can open more than one file simultaneously and switch
  between them using the <i>Buffers</i> pull-down menu.  You probably
  won't want to open more than one copy of XEmacs, choosing to use
  multiple buffers instead.
</p>
<p>
  As you become more familiar with the editor, you will probably want
  to learn the keybindings to often-used commands.  For instance:
</p>
<table border="0">
  <tr>
    <td>Ctrl-x Ctrl-s</td><td>Save the current buffer</td>
  </tr>
  <tr>
    <td>Ctrl-x Ctrl-f</td><td>Find a file by name and open it in a buffer</td>
  </tr>
  <tr>
    <td>Ctrl-x 2</td><td>Split the screen into two windows (to see
      two files simultaneously</td>
  </tr>
  <tr>
    <td>Ctrl-x 1</td><td>Return to only one window</td>
  </tr>
  <tr>
    <td>Ctrl-x o</td><td>Switch from one window to another</td>
  </tr>
  <tr>
    <td>Ctrl-g</td><td>Abort the command prompt if you accidentally
	open it</td>
  </tr>
</table>
<p>
  We strongly suggest you take a look at the UNIX and XEmacs tutorials at:
  <a href="http://www.cse.ohio-state.edu/sce/reference/xemacs/contents.html">UINX and XEmacs Tutorials</a>.
</p>
<p>
  More information on how to use XEmacs is available through the Help
  menu or from your TA.
</p>

<h4>vim</h4>

<p>
  vim is an enhanced version of the <tt>vi</tt> editor, which has been
  the "standard" editor on UNIX for years.  Vim adds features such as
  syntax hilighting, extended macros, and smart indenting to the same
  vi that UNIX users have always had.  If you're already a vi user,
  you should consider trying vim.
</p>
<p>
  To start vim, type:
</p>
<blockquote>
  <p>
    <i>csh&gt;</i> <tt>vim <i>filename</i></tt>
  </p>
</blockquote>
<p>
  The majority of vim commands are the same as their vi counterparts,
  with some additions.  An addition you may be immediately interested
  in is <tt>:syntax on</tt>, which will turn on syntax hilighting.
  The <tt>vimtutor</tt> command provides a nice beginner's tutorial,
  and the <tt>:help</tt> command is quite extensive.
</p>

<h2>Assignment</h2>

<h3>Part 1: C/C++ Review</h3>

<p>
  In this part of the lab you will review C strings, double pointers,
  and pointers to functions.
</p>

<h4>Instructions</h4>

<ol>
  <li>
    <p>
      Download the file 
      <a href="lab1-src.tar.gz">lab1-src.tar.gz</a>
      to your home directory on the sslab machines.  It
      contains everything you will need for this part of the
      assignment.  Extract it as follows:
    </p>
    <blockquote>
      <p>
        <i>csh&gt;</i> <tt>gzip -dc lab1-src.tar.gz | tar xvf -</tt>
      </p>
    </blockquote>
    <p>
      This will create a <tt>lab1-src</tt> subdirectory containing the
      files you will use in this part of the assignment. This subdirectory
      will be created under the directory where you downloaded the file
      (and unzipped and untarred it), e.g., your home directory.
    </p>
  </li>
  <li>
    <p>
      Complete the functions in the files <tt>mystring.c</tt>,
      <tt>List.cc</tt>, and <tt>mysort.cc</tt>.
      <em><strong>Important:</strong> use C or C++ according to the files 
      given to you-- do NOT change from one to the other.</em>  You may
      not use any of the <tt>str*</tt> functions (<tt>strdup</tt>,
      <tt>strlen</tt>, <tt>strcpy</tt>, etc.) in <tt>mystring.c</tt>, and
      you may not use the <tt>qsort</tt> function in <tt>mysort.cc</tt>.
      Use your best judgment for other functions -- if it seems like
      cutting corners, it probably is.
    </p>
  </li>
  <li>
    <p>
      You are provided with very simple test programs (<tt>test_mystring</tt>,
      <tt>test_mysort</tt>, and <tt>test_list</tt>. 
      Make sure all your tests compile correctly by typing
      <tt>make</tt>.  You will have to edit the Makefile, since it is
      missing one target.  <strong>Please note, however, that the tests
      given are just simple example tests.  Part of the assignment is for
      you to develop more sophisticated tests.  For example, you may want
      to check the error handling you implement by ensuring your program
      does not crash even when provided with erroneous parameters.</strong>
    </p>
  </li>
</ol>

<h3>Part 2: Memory layout of a program</h3>

<p>
  The image of a running program (its memory layout) consists of the
  following sections:
</p>

<table border="2">
  <tr>
    <th>Memory&nbsp;Section&nbsp;Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>text (or code segment)</td>
    <td>This is the area of memory that contains the machine
      instructions corresponding to the compiled program. This
      area is READ ONLY and is shared by multiple instances of
      a running program.</td>
  </tr>
  <tr>
    <td>data</td>
    <td>This area in the memory image of a running program contains
      storage for <b>initialized global</b> variables. This area is
      separate for each running instance of a program.</td>
  </tr>
  <tr>
    <td>bss</td>
    <td>This is the memory area that contains storage for
      <b>uninitialized global</b> variables.  It is also separate for
      each running instance of a program.</td>
  </tr>
  <tr>
    <td>stack</td>
    <td>This region of the memory image of a running program contains
      storage for the automatic (local) variables of the program. It
      also stores context-specific information before a function call,
      <i>e.g.</i> the value of the Instruction Pointer (Program
      Counter) register before a function call is made.  On most
      architectures the stack grows from <b>higher memory to lower
      memory addresses</b>.</td>
  </tr>
  <tr>
    <td>heap</td>
    <td>This memory region is reserved for dynamically allocating
      memory for variables, at run time. Dynamic memory allocation
      is done by using the <tt>malloc</tt> or <tt>calloc</tt>
      functions.</td>
  </tr>
  <tr>
    <td>shared libraries</td>
    <td>This region contains the executable image of shared libraries
      being used by the program.</td>
  </tr>
</table>

<h4>Instructions</h4>

<ol>
  <li>
    <p>
      Use XEmacs or vim to enter the following program as <tt>lab1.c</tt>.
      Compile and run it.
    </p>
    
    <pre>
    /* lab1.c*/
    
    int a = 25;   /*initialized global var*/
    int b[45000]; /*uninitialized global var*/
    int d[45000]; /*uninitialized global var*/
    
    void donothing();
    
    int main()
    {
        char c=25;
        int  *ptr;
    
        printf("Address of the function donothing() is 0x%lx\n", donothing);
        printf("Address of integer a is 0x%lx\n", &amp;a);
        printf("Address of array b is 0x%lx\n", b);
        printf("Address of array d is 0x%lx\n", d);
        printf("Address of character c is 0x%lx\n", &amp;c);
    
        ptr = (int *)malloc(sizeof(int));
        printf("Address of integer pointer ptr is 0x%lx\n", &amp;ptr);
    
        printf("Address of the integer pointed to by ptr is 0x%lx\n", ptr);
    
        donothing();
        sleep(60);
        return 0;
    }
    
    void donothing()
    {
        int local;
    
        printf("\nAddress of integer local is 0x%lx\n", &amp;local);
    
        return;
    }
    </pre>
    
    <p>
      To compile and run this, type:
    </p>
    <blockquote>
      <p>
        <i>csh&gt;</i> <tt>gcc -o lab1 lab1.c</tt><br>
        <i>csh&gt;</i> <tt>./lab1</tt>
      </p>
    </blockquote>
  </li>
  <li>
    <p>
      Use the command <tt>/usr/proc/bin/pmap</tt> to print the memory
      mappings of the <tt>lab1</tt> program while it is executing.  To
      do this, run the command <tt>lab1</tt> in one window, and type
      the following command in another window to determine the process
      ID of the <tt>lab1</tt> program (be careful to note the PID, not
      the PPID):
    </p>
    <blockquote>
      <p>
        <i>csh&gt;</i> <tt>ps -ef | grep lab1</tt>
      </p>
    </blockquote>
    <p>
      Now that you know the PID of your <tt>lab1</tt> program, run:
    </p>
    <blockquote>
      <p>
        <i>csh&gt;</i> <tt>/usr/proc/bin/pmap <i>PID</i></tt>
      </p>
    </blockquote>
    If you have problems understanding the output (or options) of ps or
    pmap, check the man pages by typing "man ps" or "man pmap".<p>
  </li>
  <li>
    <p>
      Use the output of the <tt>pmap</tt> program to fill out a simple
      table in a file named <tt>mappings.txt</tt> showing the location
      of the following symbols:
    </p>
    <ul>
      <li>donothing</li>
      <li>&amp;a</li>
      <li>b</li>
      <li>d</li>
      <li>&amp;c</li>
      <li>&amp;ptr</li>
      <li>ptr</li>
      <li>&amp;local</li>
    </ul>
    <p>
      The only valid locations are <tt>text</tt>, <tt>data</tt>, <tt>bss</tt>,
      <tt>stack</tt>, <tt>heap</tt>, and <tt>shared library</tt> (watch your
      case!).  The file should be of the format:
    </p>
    <blockquote>
      <p>
        <tt>symbol location</tt><br>
        <tt>symbol location</tt>
      </p>
    </blockquote>
    <p>
      Where the symbol and location are separated by one or more
      spaces, and each symbol, location pair is on a line by itself.
      For example:
    </p>
    <blockquote>
      <p>
        <tt>&amp;somevariable stack</tt><br>
        <tt>&amp;errno shared library</tt>
      </p>
    </blockquote>
    <p>
      <em><strong>Important:</strong> It is critical that the format
      of this file is correct.  NOTE THAT THE LOCATIONS WILL BE CHECKED
      USING A CASE-SENSITIVE MATCH.  If you have any questions, please ask
      your TA.</em>
    </p>
  </li>
</ol>

<h3>Part 3: GDB</h3>

<p>
  In this part of the lab you will learn about the <tt>gdb</tt>
  debugger, a powerful interactive debugger for many compiled
  languages.  We will of course be focusing on C and C++.
</p>
<p>
  GDB can be used in one of two major fashions -- at runtime (gdb is
  started before there is a problem) or post-mortem (gdb is run to
  determine why a program that has already died did so).  Runtime
  debugging is desirable whenever possible, but post-mortem debugging 
  is useful when you have a process that fails in some unexpected way
  and leaves a core.
</p>
<p>
  These two major modes of operation are invoked in different
  fashions.  To debug a program at run time, you can either start the
  program from within gdb or attach to an already running program.  To
  start a program within gdb, you would do the following:
</p>
<blockquote>
  <p>
    <i>csh&gt;</i> <tt>gdb <i>progname</i></tt><br>
    <i>(gdb)</i> <tt>run</tt>
  </p>
</blockquote>
<p>
  Note that you might want to set some breakpoints or watchpoints
  (discussed later) before running the program.  The second common
  form of runtime debugging is attaching gdb to a process that is
  already running.  This requires you to know the PID of the running
  process you are interested in:
</p>
<blockquote>
  <p>
    <i>csh&gt;</i> <tt>gdb <i>progname</i> <i>pid</i></tt>
  </p>
</blockquote>
<p>
  After connecting in this fashion the program can be debugged
  normally, as if you had started gdb and run the program from there.
</p>
<p>
  To invoke gdb for post-mortem debugging, you must have both the
  binary you wish to debug and the core file from where it failed.
  (FYI, you can often force a core dump with Ctrl-\ [control
  backslash].  However, it is often more useful to attach gdb to the
  running process than force a core.)
</p>
<blockquote>
  <p>
    <i>csh&gt;</i> <tt>gdb <i>progname</i> <i>corefile</i></tt>
  </p>
</blockquote>
<p>
  Core files can also be loaded at runtime with the <tt>core-file</tt>
  command, and executables can be loaded with the <tt>exec-file</tt>
  command.
</p>

<p>
  Once you have your program open in gdb, you are likely going to want
  to do some debugging on it.  Here is a brief list of commands you
  are likely to find useful.
</p>
<table border="2">
  <tr>
    <th>Command&nbsp;syntax</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>
      <tt>break</tt><br>
      <tt>break&nbsp;<i>linenumber</i></tt><br>
      <tt>break&nbsp;<i>filename:linenumber</i></tt><br>
      <tt>break&nbsp;<i>function</i></tt>
    </td>
    <td>
      These commands set a "breakpoint", or a place where the debugger
      should suspend operation of the debugger and ask for further
      input.  Play with their arguments a little to see how flexible
      <tt>break</tt> is.
    </td>
  </tr>
  <tr>
    <td>
      <tt>bt</tt><br>
      <tt>where</tt>
    </td>
    <td>
      The <tt>bt</tt> and <tt>where</tt> commands are functionally
      identical.  They cause gdb to print a "backtrace", or listing
      of the function call stack of the current program.  This is
      very useful for determining where and why a program died.  You
      should play with this command on both programs that have crashed
      and programs that are running normally to get a feel for how it
      works.
    </td>
  </tr>
  <tr>
    <td>
      <tt>cont</tt>
    </td>
    <td>
      This command continues execution where it was last stopped,
      either by <tt>break</tt>, <tt>watch</tt>, Ctrl-C, a signal, or
      some other action.
    </td>
  </tr>
  <tr>
    <td>
      <tt>help</tt><br>
      <tt>help <i>topic</i></tt><br>
      <tt>help <i>command</i></tt>
    </td>
    <td>
      Gdb includes an extraordinarily comprehensive help system.  The
      bare command <tt>help</tt> will generate a list of high-level
      topics which can be researched in more depth by giving arguments
      to the <tt>help</tt> command.  If you think gdb should probably
      be able to do some particular thing, look here -- it probably
      can.
    </td>
  </tr>
  <tr>
    <td>
      <tt>info <i>category</i></tt>
    </td>
    <td>
      This prints information about some part of your program or gdb's
      configuration; you may find the categories <tt>locals</tt>,
      <tt>variables</tt>, <tt>functions</tt>, and <tt>display</tt>
      useful.
    </td>
  </tr>
  <tr>
    <td>
      <tt>next</tt>
    </td>
    <td>
      Execute the current line of code and proceed to the next,
      treating subroutine calls as one line.
    </td>
  </tr>
  <tr>
    <td>
      <tt>print <i>expression</i></tt>
    </td>
    <td>
      <tt>print</tt> is one of the most powerful commands in gdb; it
      is used to print the value of an arbitrary expression, such as a
      simple variable, a calculation, or a function call.  The power
      of <tt>print</tt> stems from the fact that <i>expression</i> can
      be a quite complex C or C++ expression, and it will be executed
      just as if your program had done it; for instance, if the
      variable <tt>x</tt> is equal to 5 and you know that it should be
      six, the command <tt>print x = 6</tt> will print the number "6",
      but will more importantly change the actual value of the
      variable <tt>x</tt>.  This can be used to both determine why
      a section of code is failing and to prevent it from doing so, as
      well as to test corner cases and bounds in your code that may
      not be easily reached through test cases.
    </td>
  </tr>
  <tr>
    <td>
      <tt>step</tt>
    </td>
    <td>
      Like <tt>next</tt>, only <tt>step</tt> enters subroutines,
      treating the first line of a called subroutine as the next line
      of code.
    </td>
  </tr>
  <tr>
    <td>
      <tt>watch <i>expression</i></tt>
    </td>
    <td>
      <tt>watch</tt> is like <tt>break</tt>, except that it will stop
      the program's execution whenever the value of the given
      expression changes, rather than at a specific point in program
      flow.  Watchpoints can make your program run significantly
      slower if they have to be constantly checked, so set them
      carefully.
    </td>
  </tr>
</table>
<p>
  Remember that the source code line printed to the screen when the
  program stops is the <em>next</em> line to be executed, it has not
  yet run.
</p>
<p>
  To find other resources google "gdb tutorial".
</p>

<h4>Instructions</h4>

<p>
  Under your <tt>lab1-src/</tt>
  directory you will find a program called <tt>debug</tt> and partial
  source to this program.  (<strong>NB:</strong> the <tt>debug</tt> 
  executable is a x86 executable and will only run correctly on
  the sslab01-sslab20 machines)  This program contains
  several bugs, some of which are serious enough to make it crash.
  Your task is to fix its crashes and more subtle bugs.  At several
  points during its execution, it will print lines like:
</p>
<blockquote>
  <p>
    <tt>Array token: grqpnerjXyVdM</tt>
  </p>

</blockquote>
  <p>
  These lines are different for each student.
  </p>

<p>
  Copy these lines (and only these lines!) and paste them into a file
  called <tt>gdbtokens.txt</tt> in your <tt>lab1-src</tt> directory,
  to be submitted with the rest of the project.  Use the commands
  listed above as well as other gdb commands you may learn looking
  through the help to make the program execute correctly.  Note well
  that you are to copy the <em>entire line</em>, not just the token
  itself.
</p>

  <p>
  Your goal is to find what the bugs are and fix them temporally inside gdb
  so the execution can reach the point where these lines are printed.

  <p>
  For example, follow this gdb interaction:
  </p>
  <pre>
bash-2.05$ gdb debug
GNU gdb (Gentoo 7.5 p1) 7.5
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-pc-linux-gnu".
For bug reporting instructions, please see:
<http://bugs.gentoo.org/>...
Reading symbols from /u/data/u3/grr/cs252/lab1-gdb-x86/lab1-src/debug...done.
(gdb) 
</pre><p>
Now set a breakpoint in main so the execution will stop there.
      <pre>
(gdb) break main
Breakpoint 1 at 0x10bb8: file public.c, line 19.
</pre><p>
    Now run the program.
<pre>
(gdb) run
Starting program: /u/data/u3/grr/cs252/lab1-gdb-x86/lab1-src/debug 
warning: Could not load shared library symbols for linux-vdso.so.1.
Do you need "set solib-search-path" or "set sysroot"?

Breakpoint 1, main (argc=1, argv=0x7fffffffe058) at public.c:19
19        printf ("Starting tests.\n");
</pre>
Now the program has stopped in the first line of main. <p>
</pre>
In an editor open the file "public.c" so you can see line 19.
To go to line 20 in"vi" type ":19".<p>
To go to line 20 in xemacs type "esc-g 19" and enter.<p>
Now type "next" ("n" for short) to execute line by line without
entering to functions, or "step" ("s" for short) to enter into
a function.
<pre>
(gdb) n
Starting tests.
20        fflush (stdout);
(gdb) n
22        initialize_array ();
(gdb) s
initialize_array () at public.c:37
37        int *numbers = NULL, i = 0;
(gdb) n
39        for (i = 0; i < 4; i++) {
(gdb) n
40          numbers[i] = i + 1;
(gdb) n

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400ce8 in initialize_array () at public.c:40
40          numbers[i] = i + 1;
</pre>
Check what is causing the crash. First print the value of "i"
<pre>
(gdb) print i
$1 = 0
</pre>
Since "i" has a correct value, now check the value of "numbers".
<pre>
(gdb) print numbers
$2 = (int *) 0x0
</pre>

The array "numbers" has not been initialized. To fix it temporally
we need to initialize it with a call to malloc. Run the program again but
this time initialize "numbers" with a call to malloc of the
right size. By looking at the program listing we can see that
it needs 5 elements.
<pre>
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /u/data/u3/grr/cs252/lab1-gdb-x86/lab1-src/debug 
warning: Could not load shared library symbols for linux-vdso.so.1.
Do you need "set solib-search-path" or "set sysroot"?

Breakpoint 1, main (argc=1, argv=0x7fffffffe058) at public.c:19
19        printf ("Starting tests.\n");
(gdb) n
Starting tests.
20        fflush (stdout);
(gdb) 
22        initialize_array ();
(gdb) s
initialize_array () at public.c:37
37        int *numbers = NULL, i = 0;
(gdb) s
39        for (i = 0; i < 4; i++) {
(gdb) print numbers=(int*)malloc(5*sizeof(int))
$2 = (int *) 0x603010
(gdb) n
40          numbers[i] = i + 1;
(gdb) n
39        for (i = 0; i < 4; i++) {
(gdb) 
40          numbers[i] = i + 1;
(gdb) 
39        for (i = 0; i < 4; i++) {
(gdb) 
40          numbers[i] = i + 1;
(gdb) 
39        for (i = 0; i < 4; i++) {
(gdb) 
40          numbers[i] = i + 1;
(gdb) 
39        for (i = 0; i < 4; i++) {
(gdb) 
42        numbers[4] = 0;
(gdb) 
44        private_array_check (numbers);
45      }
(gdb) 
</pre><p>
The problem seems to be solved and you are about to execute the procedure that
will print the line that you will paste in the file gdbtokens.txt. Type "next".

<pre>
(gdb) s
Array token: arxG92Rj/DpZ2
(gdb) next
45      }
(gdb) 
</pre>
<p>
Copy and paste this line in the file gdbtokens.txt. These lines are different for
each student.
<p>
There are three procedures that you have to fix including the one
mentioned above so you will need to paste three lines in the file
gdbtokens.txt. Remember that the "print" statement in gdb can be used to temporally
fix the code in the program you are debugging. Also, another hint is that if
you type the enter key in gdb it will execute the last command you typed.
    
<p>
  More help on gdb can be found at the
  <a href="http://www.gnu.org/software/gdb/">gdb homepage</a>, as well
  as in many online tutorials.  (Try searching for <tt>gdb
  tutorial</tt> on Google.)
</p>

<h2>Turning in the project</h2>

    This project is due on Monday, January 28th, 2013 before 11:59 PM.

<ol>
  <li>Make sure the files <tt>mappings.txt</tt> and
    <tt>gdbtokens.txt</tt> are in your <tt>lab1-src</tt>
    directory.</li>
  <li>Change directories to your <tt>lab1-src</tt> directory.</li>
  <li>Type '<tt>make</tt>' and ensure that everything built 
    correctly.</li>
  <li>Type '<tt>make clean</tt>' to clean up the object files.</li>
  <li>Use '<tt>cd ..</tt>' to change to the parent directory of your
    <tt>lab1-src</tt> directory.</li>
  <li>Type '<tt>turnin -c cs252 -p lab1 lab1-src</tt>' to submit your
    work for lab 1.</li>
  <li>Type '<tt>turnin -c cs252 -p lab1 -v</tt>' and verify that the
    files you submitted are correct.</li>
</ol>
<p>
</body>
</html>
